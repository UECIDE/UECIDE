/*
 * Copyright (c) 2014, Majenko Technologies
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright notice, this
 *   list of conditions and the following disclaimer in the documentation and/or
 *   other materials provided with the distribution.
 *
 * * Neither the name of Majenko Technologies nor the names of its
 *   contributors may be used to endorse or promote products derived from
 *   this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package org.uecide.preproc;

import org.uecide.*;

import java.io.*;
import java.util.*;

import java.util.regex.*;

/**
 * Class that orchestrates preprocessing p5 syntax into straight Java.
 */
public class PdePreprocessor {

    // stores number of built user-defined function prototypes
    public int prototypeCount = 0;

    // stores number of included library headers written
    // we always write one header: WProgram.h
    public int headerCount = 1;

    // the prototypes that are generated by the preprocessor
    List<String> prototypes;

    // these ones have the .* at the end, since a class name might be at the end
    // instead of .* which would make trouble other classes using this can lop
    // off the . and anything after it to produce a package name consistently.
    List<String> programImports;

    // imports just from the code folder, treated differently
    // than the others, since the imports are auto-generated.
    List<String> codeFolderImports;

    String indent;

    PrintStream stream;
    String program;
    String buildPath;
    // starts as sketch name, ends as main class name
    String name;


    /**
     * Setup a new preprocessor.
     */
    public PdePreprocessor() {
        int tabSize = Base.preferences.getInteger("editor.tabs.size");
        char[] indentChars = new char[tabSize];
        Arrays.fill(indentChars, ' ');
        indent = new String(indentChars);
    }

    public List<String> getSubImports(List<String> imports) {
        List<String> newImports = new ArrayList<String>();

        String importRegexp = "^\\s*#include\\s+[<\"](\\S+)[\">]";
        Pattern importPattern = Pattern.compile(importRegexp);
        InputStream in;

        for(String animport : imports) {
            File iloc = Base.importToLibraryTable.get(animport);

            if(iloc != null) {
                File incFile = new File(iloc, animport);

                if(incFile.exists()) {
                    try {
                        in = new BufferedInputStream(new FileInputStream(incFile));
                        int nr;
                        StringBuilder program = new StringBuilder();
                        byte[] buffer = new byte[1024];

                        while((nr = in.read(buffer)) > 0) {
                            String chunk = new String(buffer, 0, nr);
                            program.append(chunk);
                        }

                        in.close();

                        ArrayList<String> pieces = new ArrayList<String>();
                        String[] prog = program.toString().split("\n");

                        for(String line : prog) {
                            Matcher m = importPattern.matcher(line);

                            if(m.find()) {
                                pieces.add(m.group(1));
                            }
                        }

                        for(String thisImport : pieces) {
                            File xloc = Base.importToLibraryTable.get(thisImport);

                            if(xloc != null) {
                                if(imports.indexOf(thisImport) == -1) {
                                    newImports.add(thisImport);
                                }
                            }
                        }
                    } catch(Exception e) {
                    }
                }
            }
        }

        return newImports;
    }

    static String substituteUnicode(String program) {
        // check for non-ascii chars (these will be/must be in unicode format)
        char p[] = program.toCharArray();
        int unicodeCount = 0;

        for(int i = 0; i < p.length; i++) {
            if(p[i] > 127) unicodeCount++;
        }

        // if non-ascii chars are in there, convert to unicode escapes
        if(unicodeCount != 0) {
            // add unicodeCount * 5.. replacing each unicode char
            // with six digit uXXXX sequence (xxxx is in hex)
            // (except for nbsp chars which will be a replaced with a space)
            int index = 0;
            char p2[] = new char[p.length + unicodeCount * 5];

            for(int i = 0; i < p.length; i++) {
                if(p[i] < 128) {
                    p2[index++] = p[i];

                } else if(p[i] == 160) {   // unicode for non-breaking space
                    p2[index++] = ' ';

                } else {
                    int c = p[i];
                    p2[index++] = '\\';
                    p2[index++] = 'u';
                    char str[] = Integer.toHexString(c).toCharArray();

                    // add leading zeros, so that the length is 4
                    //for (int i = 0; i < 4 - str.length; i++) p2[index++] = '0';
                    for(int m = 0; m < 4 - str.length; m++) p2[index++] = '0';

                    System.arraycopy(str, 0, p2, index, str.length);
                    index += str.length;
                }
            }

            program = new String(p2, 0, index);
        }

        return program;
    }

    /**
     * Write any necessary closing text.
     *
     * @param out         PrintStream to write it to.
     */
    protected void writeFooter(PrintStream out) {}


    public List<String> getExtraImports() {
        return programImports;
    }

    /**
     * Returns the index of the first character that's not whitespace, a comment
     * or a pre-processor directive.
     */
    public int firstStatement(String in) {
        // whitespace
        String p = "\\s+";

        // multi-line and single-line comment
        //p += "|" + "(//\\s*?$)|(/\\*\\s*?\\*/)";
        p += "|(/\\*[^*]*(?:\\*(?!/)[^*]*)*\\*/)|(//.*?$)";

        // pre-processor directive
        p += "|(#(?:\\\\\\n|.)*)";
        Pattern pattern = Pattern.compile(p, Pattern.MULTILINE);

        Matcher matcher = pattern.matcher(in);
        int i = 0;

        while(matcher.find()) {
            if(matcher.start() != i)
                break;

            i = matcher.end();
        }

        return i;
    }

    /**
     * Strips comments, pre-processor directives, single- and double-quoted
     * strings from a string.
     * @param in the String to strip
     * @return the stripped String
     */
    public String strip(String in) {
        // XXX: doesn't properly handle special single-quoted characters
        // single-quoted character
        String p = "('.')";

        // double-quoted string
        p += "|(\"(?:[^\"\\\\]|\\\\.)*\")";

        // single and multi-line comment
        //p += "|" + "(//\\s*?$)|(/\\*\\s*?\\*/)";
        p += "|(//.*?$)|(/\\*[^*]*(?:\\*(?!/)[^*]*)*\\*/)";

        // pre-processor directive
        p += "|" + "(^\\s*#.*?$)";

        Pattern pattern = Pattern.compile(p, Pattern.MULTILINE);
        Matcher matcher = pattern.matcher(in);
        return matcher.replaceAll(" ");
    }

    /**
     * Removes the contents of all top-level curly brace pairs {}.
     * @param in the String to collapse
     * @return the collapsed String
     */
    private String collapseBraces(String in) {
        StringBuffer buffer = new StringBuffer();
        int nesting = 0;
        int start = 0;

        // XXX: need to keep newlines inside braces so we can determine the line
        // number of a prototype
        for(int i = 0; i < in.length(); i++) {
            if(in.charAt(i) == '{') {
                if(nesting == 0) {
                    buffer.append(in.substring(start, i + 1));  // include the '{'
                }

                nesting++;
            }

            if(in.charAt(i) == '}') {
                nesting--;

                if(nesting == 0) {
                    start = i; // include the '}'
                }
            }
        }

        buffer.append(in.substring(start));

        return buffer.toString();
    }

    public ArrayList<String> prototypes(String in) {
        in = collapseBraces(strip(in));

        // XXX: doesn't handle ... varargs
        // XXX: doesn't handle function pointers
        Pattern pattern = Pattern.compile("[\\w\\[\\]\\*]+\\s+[&\\[\\]\\*\\w\\s]+\\([&,\\[\\]\\*\\w\\s]*\\)(?=\\s*\\{)");

        ArrayList<String> matches = new ArrayList<String>();
        Matcher matcher = pattern.matcher(in);

        while(matcher.find())
            matches.add(matcher.group(0) + ";");

        return matches;
    }
}
